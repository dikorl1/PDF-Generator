#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Скрипт генерации PDF из CSV/JSON данных по HTML-шаблону.
Поддержка кириллицы через xhtml2pdf и системный шрифт (Arial / DejaVu Sans).
Работает на Windows и macOS без внешних нативных библиотек.
"""

import csv
import json
import os
import re
import platform
import subprocess
from pathlib import Path

# Опционально: pandas для CSV (если доступен)
try:
    import pandas as pd
    HAS_PANDAS = True
except ImportError:
    HAS_PANDAS = False

# PDF строится через ReportLab (шрифт с кириллицей регистрируется явно).

# Директории (относительно скрипта)
BASE_DIR = Path(__file__).resolve().parent
OUTPUT_DIR = BASE_DIR / "output"

# Маппинг плейсхолдеров шаблона на возможные имена полей в данных
PLACEHOLDER_MAP = {
    "company": ["company", "название компании", "названиекомпании", "company_name", "name"],
    "date": ["date", "дата", "Дата"],
    "price": ["price", "цена", "price_per_unit"],
    "quantity": ["quantity", "количество", "Quantity"],
    "total": ["total", "сумма", "Сумма", "amount"],
}


FONT_NAME = "CyrillicFont"


def get_cyrillic_font_path():
    """Возвращает (путь_к_папке_шрифтов, имя_файла) для reportlab."""
    system = platform.system()
    if system == "Windows":
        windir = os.environ.get("WINDIR", "C:\\Windows")
        fonts_dir = Path(windir) / "Fonts"
        for name in ("arial.ttf", "arialuni.ttf", "times.ttf"):
            if (fonts_dir / name).exists():
                return str(fonts_dir.resolve()), name
    elif system == "Darwin":
        for base in ["/System/Library/Fonts/Supplemental", "/Library/Fonts"]:
            for name in ("Arial.ttf", "Arial Unicode.ttf"):
                path = Path(base) / name
                if path.exists():
                    return str(Path(base).resolve()), name
        for p in ("/usr/local/share/fonts", "/opt/homebrew/share/fonts"):
            p = Path(p)
            if p.exists():
                for f in p.rglob("DejaVuSans.ttf"):
                    return str(f.parent), f.name
    return None, None


def register_cyrillic_font():
    """Регистрирует шрифт с кириллицей в reportlab. Возвращает True при успехе."""
    font_dir, font_file = get_cyrillic_font_path()
    if not font_dir or not font_file:
        return False
    try:
        import reportlab
        from reportlab.pdfbase import pdfmetrics
        from reportlab.pdfbase.ttfonts import TTFont
        if font_dir not in reportlab.rl_config.TTFSearchPath:
            reportlab.rl_config.TTFSearchPath.append(font_dir)
        pdfmetrics.registerFont(TTFont(FONT_NAME, font_file))
        return True
    except Exception:
        return False


def get_record_display(record):
    """Из записи извлекает поля для чека: company, date, price, quantity, total."""
    def get(key_candidates):
        for c in key_candidates:
            for k, v in record.items():
                if k.lower().replace(" ", "") == c.lower().replace(" ", ""):
                    return v or ""
                if k.lower() == c.lower():
                    return v or ""
        return ""
    return {
        "company": get(PLACEHOLDER_MAP["company"]),
        "date": get(PLACEHOLDER_MAP["date"]),
        "price": get(PLACEHOLDER_MAP["price"]),
        "quantity": get(PLACEHOLDER_MAP["quantity"]),
        "total": get(PLACEHOLDER_MAP["total"]),
    }


def get_cyrillic_css():
    """CSS для xhtml2pdf (если понадобится)."""
    return """
body, .container, table, th, td, header, h1, p {
    font-family: PdfCyrillic, Arial, sans-serif !important;
}
"""


def ensure_output_dir():
    """Создаёт директорию output при отсутствии."""
    OUTPUT_DIR.mkdir(parents=True, exist_ok=True)


def get_data_files():
    """Возвращает списки путей к CSV и JSON в BASE_DIR."""
    csv_files = sorted(BASE_DIR.glob("*.csv"))
    json_files = sorted(BASE_DIR.glob("*.json"))
    return list(csv_files), list(json_files)


def get_template_files():
    """Возвращает список HTML-шаблонов в BASE_DIR."""
    return sorted(BASE_DIR.glob("*.html"))


def load_csv(path):
    """Загружает CSV через pandas или csv. Возвращает list[dict] и имена колонок."""
    path = Path(path)
    if HAS_PANDAS:
        df = pd.read_csv(path, encoding="utf-8")
        # Нормализуем ключи: пробелы и регистр для сопоставления
        data = df.to_dict(orient="records")
        # Приводим ключи к строке и сохраняем как есть для маппинга
        data = [{str(k): (v if pd.notna(v) else "") for k, v in row.items()} for row in data]
        return data
    with open(path, "r", encoding="utf-8") as f:
        reader = csv.DictReader(f)
        rows = list(reader)
    return rows


def load_json(path):
    """Загружает JSON. Ожидает массив объектов или объект с массивом (invoices/items/data)."""
    path = Path(path)
    with open(path, "r", encoding="utf-8") as f:
        raw = json.load(f)
    if isinstance(raw, list):
        return raw
    if isinstance(raw, dict):
        for key in ("invoices", "items", "data", "records", "rows"):
            if key in raw and isinstance(raw[key], list):
                return raw[key]
        # Один объект — оборачиваем в список
        return [raw]
    return []


def normalize_record(record):
    """Приводит запись к dict с строковыми ключами и значениями."""
    out = {}
    for k, v in record.items():
        key = str(k).strip()
        out[key] = "" if v is None else str(v).strip()
    return out


def get_invoice_id(record, index, keys_lower):
    """Возвращает идентификатор чека: invoice_id / id / номер по счёту или индекс."""
    if "invoice_id" in keys_lower:
        for k, v in record.items():
            if k.lower() == "invoice_id" and v:
                return v
    if "id" in keys_lower:
        for k, v in record.items():
            if k.lower() == "id" and v:
                return v
    return str(index + 1)


def fill_template(template_path, record, extra_css=""):
    """Подставляет record в HTML-шаблон, возвращает HTML-строку."""
    with open(template_path, "r", encoding="utf-8") as f:
        html = f.read()

    placeholders = set(re.findall(r"\{(\w+)\}", html))
    for name in placeholders:
        value = ""
        for candidate in PLACEHOLDER_MAP.get(name.lower(), [name]):
            for key, val in record.items():
                if key.lower().replace(" ", "") == candidate.lower().replace(" ", ""):
                    value = val
                    break
                if key.lower() == name.lower():
                    value = val
                    break
            if value:
                break
        html = html.replace("{" + name + "}", value)

    if extra_css:
        html = html.replace("</style>", extra_css + "\n</style>")
    return html


def render_pdf_reportlab(record, output_path, template_path=None):
    """Строит PDF через ReportLab с зарегистрированным шрифтом (кириллица)."""
    if not register_cyrillic_font():
        raise RuntimeError(
            "Не найден шрифт с кириллицей. "
            "Проверьте C:\\Windows\\Fonts\\arial.ttf (Windows)."
        )
    from reportlab.lib import colors
    from reportlab.lib.pagesizes import A4
    from reportlab.lib.styles import ParagraphStyle
    from reportlab.lib.units import mm
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Table, TableStyle, Spacer

    # Стиль по выбранному шаблону: template2 — зелёный минимализм, иначе — синий отчёт
    is_template2 = template_path and Path(template_path).name.lower() == "template2.html"
    if is_template2:
        accent = colors.HexColor("#2d5a27")
        title_text = "Чек по сделке"
        subtitle_text = "Детализация"
    else:
        accent = colors.HexColor("#4facfe")
        title_text = "Финансовый отчёт"
        subtitle_text = "Данные по сделке"

    doc = SimpleDocTemplate(
        output_path,
        pagesize=A4,
        rightMargin=20 * mm,
        leftMargin=20 * mm,
        topMargin=15 * mm,
        bottomMargin=15 * mm,
    )
    cyrillic_title = ParagraphStyle(
        name="CyrillicTitle",
        fontName=FONT_NAME,
        fontSize=18,
        leading=22,
        spaceAfter=6,
    )
    cyrillic_small = ParagraphStyle(
        name="CyrillicSmall",
        fontName=FONT_NAME,
        fontSize=10,
        leading=12,
    )

    d = get_record_display(record)
    story = []
    story.append(Paragraph(title_text, cyrillic_title))
    story.append(Paragraph(subtitle_text, cyrillic_small))
    story.append(Spacer(1, 8 * mm))

    data = [
        ["Название компании", d["company"]],
        ["Дата", d["date"]],
        ["Цена (за ед.)", f"{d['price']} руб."],
        ["Количество", f"{d['quantity']} ед."],
        ["Сумма", f"{d['total']} руб."],
    ]
    t = Table(data, colWidths=[60 * mm, 80 * mm])
    t.setStyle(
        TableStyle(
            [
                ("FONTNAME", (0, 0), (-1, -1), FONT_NAME),
                ("FONTSIZE", (0, 0), (-1, -1), 11),
                ("BACKGROUND", (0, 0), (0, -1), colors.HexColor("#f8f9fa")),
                ("TEXTCOLOR", (0, 0), (0, -1), colors.HexColor("#555555")),
                ("ALIGN", (0, 0), (-1, -1), "LEFT"),
                ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                ("GRID", (0, 0), (-1, -1), 0.5, colors.HexColor("#eeeeee")),
                ("LEFTPADDING", (0, 0), (-1, -1), 10),
                ("RIGHTPADDING", (0, 0), (-1, -1), 10),
                ("TOPPADDING", (0, 0), (-1, -1), 10),
                ("BOTTOMPADDING", (0, 0), (-1, -1), 10),
                ("FONTNAME", (0, 4), (1, 4), FONT_NAME),
                ("FONTSIZE", (0, 4), (1, 4), 12),
                ("TEXTCOLOR", (0, 4), (1, 4), accent),
            ]
        )
    )
    story.append(t)
    doc.build(story)
    return output_path


def open_pdf(path):
    """Открывает PDF в системной программе (Windows / macOS / Linux)."""
    path = os.path.abspath(path)
    if not os.path.isfile(path):
        return
    system = platform.system()
    if system == "Windows":
        os.startfile(path)
    elif system == "Darwin":
        subprocess.run(["open", path], check=False)
    else:
        subprocess.run(["xdg-open", path], check=False)


def print_menu(title, items, allow_zero=False):
    """Печатает нумерованное меню. items — список (path или (id, label))."""
    print()
    print("=" * 50)
    print(title)
    print("=" * 50)
    for i, item in enumerate(items, start=0 if allow_zero else 1):
        if isinstance(item, (tuple, list)):
            print(f"  {i}. {item[1]}")
        else:
            print(f"  {i}. {item}")
    print("=" * 50)


def main():
    ensure_output_dir()

    csv_files, json_files = get_data_files()
    data_files = [(p, f"[CSV] {p.name}") for p in csv_files] + [
        (p, f"[JSON] {p.name}") for p in json_files
    ]
    templates = get_template_files()

    if not data_files:
        print("В директории DZ_convert не найдено ни одного CSV или JSON файла.")
        return
    if not templates:
        print("В директории DZ_convert не найдено ни одного HTML-шаблона.")
        return

    print_menu("Доступные файлы с данными", [x[1] for x in data_files])
    choice = input("Выберите номер файла с данными: ").strip()
    try:
        idx = int(choice)
        if idx < 1 or idx > len(data_files):
            print("Неверный номер.")
            return
        data_path = data_files[idx - 1][0]
    except ValueError:
        print("Введите число.")
        return

    print_menu("Доступные HTML-шаблоны", [t.name for t in templates])
    choice_t = input("Выберите номер шаблона: ").strip()
    try:
        idx_t = int(choice_t)
        if idx_t < 1 or idx_t > len(templates):
            print("Неверный номер.")
            return
        template_path = templates[idx_t - 1]
    except ValueError:
        print("Введите число.")
        return

    # Загрузка данных
    suffix = data_path.suffix.lower()
    if suffix == ".csv":
        records = load_csv(data_path)
    else:
        records = load_json(data_path)

    records = [normalize_record(r) for r in records]
    if not records:
        print("В выбранном файле нет записей.")
        return

    keys_lower = [k.lower() for k in records[0].keys()]
    invoices = [
        (get_invoice_id(rec, i, keys_lower), rec, i)
        for i, rec in enumerate(records)
    ]

    print_menu("Доступные чеки (invoice id)", [f"ID: {inv[0]}" for inv in invoices])
    choice_inv = input("Выберите номер чека (invoice): ").strip()
    try:
        idx_inv = int(choice_inv)
        if idx_inv < 1 or idx_inv > len(invoices):
            print("Неверный номер.")
            return
        invoice_id, record, _ = invoices[idx_inv - 1]
    except ValueError:
        print("Введите число.")
        return

    safe_id = re.sub(r'[^\w\-]', '_', str(invoice_id))
    out_name = f"invoice_{safe_id}.pdf"
    output_path = OUTPUT_DIR / out_name

    print("\nГенерация PDF...")
    try:
        render_pdf_reportlab(record, str(output_path), template_path=template_path)
    except Exception as e:
        print(f"Ошибка при создании PDF: {e}")
        return

    print(f"PDF сохранён: {output_path}")
    open_pdf(str(output_path))
    print("Готово.")


if __name__ == "__main__":
    main()
